(library (nmosh internal buildsystem gen-ucid)
         (export gen-ucid genucid-cmd genucid)
         (import (rnrs)
                 (shorten)
                 (srfi :8)
                 (srfi :26)
                 (srfi :48)
                 (yuni util files)
                 (yuni core)
                 (mosh pp)
                 (match)
                 (nmosh internal buildsystem gen callstub))

(define (libname->c-symbol lis)
  (fold-left (^[cur e] (format "~a_~a" cur e))
             "moshplugin"
             lis))

(define (libname->dir+filename lis)
  (define r (reverse lis))
  (let ((head (reverse (cdr r)))
        (name (car r)))
    (values
      (fold-left (^[cur e] (format "~a/~a" cur e))
                 "lib/nmosh/ext"
                 head)
      (format "~a.sls" name))))

(define core-types
  ;; (sym export-type mosh-type c-type)
  '((int8  int int8_t int8_t)
    (uint8 uint int uint8_t) ;; FIXME: Why `int` here?
    (int16 int int16_t int16_t)
    (uint16 uint uint16_t uint16_t)
    (int32 int int32_t int32_t)
    (uint32 uint uint32_t uint32_t)
    (int64 int int64_t int64_t)
    (uint64 uint uint64_t uint64_t)
    (intptr int int64_t int64_t)
    (uintptr uint uint64_t uint64_t)
    (size_t uint size_t size_t)
    (int int int int)
    (uint uint unsigned-int "unsigned int")
    (short int short short)
    (ushort uint unsigned-short "unsigned short")
    (float float float double)
    (double double double double)
    ;; void types must be a symbol (eq? comparable)
    (void #f void void)
    (void* pointer void* void*)
    ;; Special character types
    (char* pointer char* char*)))

(define (core-type? sym)
  (find (^e (eq? (car e) sym)) core-types))

(define (core-export-type sym)
  (let ((f (find (^e (eq? (car e) sym)) core-types)))
    (match f
           ((sym export-type mosh-type c-type)
            export-type)
           (else #f))))

(define (core-c-type sym)
  (let ((f (find (^e (eq? (car e) sym)) core-types)))
    (match f
           ((sym export-type mosh-type c-type)
            c-type)
           (else 
             (assertion-violation 'core-c-type
                                  "Invalid core type"
                                  sym)))))

;; Source writers
(define (make-cref lis/sym)
  (if (pair? lis/sym)
    (fold-left (^[cur e] (format "~a.~a" cur e))
               (car lis/sym)
               (cdr lis/sym))
    lis/sym))

(define (make-cref/str lis/sym)
  (if (pair? lis/sym)
    (fold-left (^[cur e] (format "~a/~a" cur e))
               (symbol->string (car lis/sym))
               (cdr lis/sym))
    (symbol->string lis/sym)))

(define (csrc-header p)
  (format p "/* Generated by gen-ucid. DO NOT EDIT. */\n\n")
  (format p "#include <nmosh/plugin-if.h>\n"))

(define (csrc-exports p namesym lis)
  ;; Write export decl.
  ;; (#t typename structure? (fields ...) (core-attr ...) ...) 
  ;; fields = (type (attr ...) path ...)
  ;;
  ;; constant := (type . name)
  ;; type = int | uint | pointer | float | double
  (define (ent e)
    (match e
           ((#t typename structure? field* attr*)
            (let ((name (if structure? 
                          (format "struct ~a" typename)
                          typename)))
              (define (emit-field/offset+size path)
                ;; Emit offsetof
                (format p 
                        "  NMOSH_EXPORT_RAW(\"offsetof/~a\",offsetof(~a, ~a))\n"
                        (make-cref/str path)
                        name
                        (make-cref (cdr path)))
                ;; Emit sizeof
                (format p 
                        "  NMOSH_EXPORT_RAW(\"sizeof/~a\",sizeof(((~a *)0)->~a))\n"
                        (make-cref/str path)
                        name
                        (make-cref (cdr path))))
              (define (emit-field/type type path)
                (format p
                        "  NMOSH_EXPORT_CSTRING(\"typeof/~a\",~w)\n"
                        (make-cref/str path)
                        (symbol->string type)))
              (define (emit-fields fn)
                (match fn
                       ((type attr* path ...)
                        (emit-field/offset+size (cons typename path))
                        (emit-field/type type (cons typename path)))))
              (define (emit-sizeof-root)
                ;; Emit root size-of
                (format p
                        "  NMOSH_EXPORT_RAW(\"sizeof/~a\",sizeof(~a))\n"
                        typename name))
              (emit-sizeof-root)
              (for-each emit-fields field*)))
           ((type . name)
            (case type
              ((float double)
               ;; FIXME: Always treated as double...
               (format p "  NMOSH_EXPORT_DOUBLE(\"~a\",~a)\n" name name) )
              ((int)
               (format p "  NMOSH_EXPORT_INT(\"~a\",~a)\n" name name))
              ((uint)
               (format p "  NMOSH_EXPORT_RAW(\"~a\",~a)\n" name name))
              ((pointer)
               (format p "  NMOSH_EXPORT_POINTER(\"~a\",~a)\n" name name))))))
  (format p "NMOSH_CONSTANT_BEGIN(~a)\n" namesym)
  (for-each ent lis)
  (format p "NMOSH_CONSTANT_END()\n")
  (format p "NMOSH_PLUGIN_DEFINE_WITH_CONSTANTS(~a)\n" namesym))

(define (attribute-set! usym attrib value)
  (let-with usym (attribute-ht)
    (unless (attribute-undefined? (attribute-ref usym attrib))
      ;; FIXME: Warn here.
      'ok)
    (hashtable-set! attribute-ht attrib value)))

(define (attribute-ref usym attrib)
  (let-with usym (attribute-ht)
    (hashtable-ref attribute-ht attrib '())))

(define (make-attribute* lis)
  (define ht (make-eq-hashtable))
  (for-each (^e (match e 
                       ((name . attr)
                        (hashtable-set! ht name attr)) 
                       (name
                         (hashtable-set! ht name name))))
            lis)
  ht)

(define (attribute-undefined? val) (null? val))

(define* ucid-symbol
  (symtype      ;; = func | struct | type | constant 
                ;;   | entry-funcarg | entry-struct
    basetype    ;; = type for constant or type
    lowerd-type ;; = lowerd type for pFFI call/scheme mangl
    parent      ;; = symbol for the parent object, which we lives in
    c-struct?   ;; = #t if we need 'struct' on C source
    sym         ;; = primary key for locate symbol
    name        ;; = name for source text. May be #f
    argorder    ;; = Argument order for functions
    attribute-ht))

;; Symbol attributes
;;  version :: version ID
;;
;; Scalar value attributes
;;  enum    :: Enum syms
;;  bits    :: Bits syms
;;  func    :: Function decl / Function type
;; 
;; Function attributes
;;  async      :: Called once from another thread
;;  callback   :: Called
;;  (FIXME: unlimited extent - How do we destruct callback object?)

(define* (aggregate? (ucid-symbol))
  (case (~ ucid-symbol 'symtype)
    ((struct) #t)
    (else #f)))

(define* (aggregate-entry? (ucid-symbol))
  (case (~ ucid-symbol 'symtype)
    ((entry-funcarg entry-struct) #t)
    (else #f)))

(define* (function? (ucid-symbol))
  (case (~ ucid-symbol 'symtype)
    ((func) #t)
    (else #f)))

(define* (internal? (ucid-symbol))
  (define r (attribute-ref ucid-symbol 'internal))
  (and r (not (null? r))))

(define (linkup sym*)
  (define parent->child-ht (make-eq-hashtable)) ;; sym => (sym ...)
  (define objs '())
  (define (add-obj name type)
    (define me (cons type name))
    (set! objs (cons me objs)))
  (define (add-agg typename struct? fields)
    (define me (list #t typename struct? fields '()))
    (set! objs (cons me objs)))
  (define (add-func funcname rettype argorder args)
    (define me (cons* #f funcname rettype argorder args))
    (set! objs (cons me objs)))
  (define* (typeof (ucid-symbol)) ;; => int | uint | pointer
    (let-with ucid-symbol (lowerd-type)
      (let ((e (core-export-type lowerd-type)))
        (unless e
          (assertion-violation 'linkup-typeof
                               "Invalid basetype"
                               lowerd-type
                               ucid-symbol)) 
        e)))
  (define (collect-fields sym)
    (define out '())
    (define (push! x) (set! out (cons x out)))
    ;; => ((lowerd-type path ...) ...)
    (define (ref sym) (hashtable-ref parent->child-ht (~ sym 'sym) '()))
    (define (one sym) (fold-left reqnext '() (ref sym)))
    (define (reqnext base sym)
      (define myname (~ sym 'name))
      ;; FIXME: Add attribute here!
      (define self `(,(~ sym 'lowerd-type) () ,@base ,myname))
      (push! self)
      (for-each (cut reqnext `(,@base ,myname) <>) (ref sym)))
    (for-each (cut reqnext '() <>) (ref sym))
    out)
  (define* (gen-parent->child-ht (ucid-symbol))
    (when (aggregate-entry? ucid-symbol) ;; Early cut
      (let-with ucid-symbol (sym parent)
        (when parent
          (let ((p (hashtable-ref parent->child-ht parent #f)))
            (cond
              ((pair? p) ;; Append
               (hashtable-set! parent->child-ht parent (cons ucid-symbol p)))
              (else ;; New entry
                (hashtable-set! 
                  parent->child-ht parent (list ucid-symbol)))))))))
  (define* (reg (ucid-symbol))
    (cond
      ((aggregate? ucid-symbol)
       ;; Structure or union
       (let-with ucid-symbol (c-struct? sym name lowerd-type)
         (let ((fields (collect-fields ucid-symbol)))
           (add-agg name c-struct? fields))))
      ((function? ucid-symbol)
       ;; C-Function
       (let-with ucid-symbol (name sym lowerd-type argorder)
         (let ((args (collect-fields ucid-symbol)))
           (add-func name lowerd-type argorder args))))
      ((eq? (~ ucid-symbol 'symtype) 'constant)
       ;; Value export
       (let-with ucid-symbol (name lowerd-type)
         (add-obj name lowerd-type)))
      ((and (not (aggregate-entry? ucid-symbol))
            (not (internal? ucid-symbol)) )
       ;; Typedef
       (let-with ucid-symbol (name sym)
         ;; Export the type alone 
         (add-agg name #f '())))  
      (else
        ;; May be Arguments
        'do-nothing)))

  ;; Pass1: First, construct back-reference of child->parent map
  (for-each gen-parent->child-ht sym*)
  ;; Pass2: Generate aggs/objs
  (for-each reg sym*)
  ;; Output result
  objs)

(define (gen-ucid file)
  (define dir (path-dirname file))
  (define (output-file name) (path-append dir name))
  (define sexp (file->sexp-list file))
  (define count 0)
  (define (gensym) 
    (set! count (+ 1 count))
    (string->symbol (format "%~a" count)))
  (define (output x sym* attributes)
    (define (append-sym x) 
      (cond
        ((pair? x)
         (set! sym* (append x sym*)) )
        (else
          (set! sym* (cons x sym*))) ))
    (define (attribute x) 
      (make-attribute* (append attributes x)))
    (define (addentries type parent x)
      ;; Append aggregate entries
      (define (gen e)
        (define me (gensym))
        (match e
               ((name basetype attr ...)
                (append-sym (make ucid-symbol
                                  (symtype type)
                                  (basetype basetype)
                                  (parent parent)
                                  (lowerd-type #f)
                                  (name name)
                                  (sym me)
                                  (attribute-ht (attribute attr)))))))
      (for-each gen x))
    (define (addstruct c-struct? typename entries* attr*)
      ;; Struct toplevel
      (append-sym (make ucid-symbol
                        (symtype 'struct)
                        (parent #f)
                        (c-struct? c-struct?)
                        (lowerd-type #f)
                        (basetype #f)
                        (name typename)
                        (sym typename)
                        (attribute-ht (attribute attr*))
                        ))
      ;; Add entries
      (addentries 'entry-struct typename entries*))
    (define (argnames lis) (map car lis))
    (define (proc e)
      (match e
             ;; Syntax
             (('attribute attr* body ...)
              (append-sym (output body '() (append attributes attr*))))

             ;; Aggregate types
             (('struct/type typename entries* attr ...)
              (addstruct #f typename entries* attr))
             (('struct typename entries* attr ...)
              (addstruct #t typename entries* attr))
             (('func funcname return-type args* attr ...)
              ;; Func toplevel
              (append-sym (make ucid-symbol
                                (symtype 'func)
                                (parent #f)
                                ;; Function type field is for return type
                                (lowerd-type #f)
                                (basetype return-type)
                                (name funcname)
                                (sym funcname)
                                (attribute-ht (attribute attr))
                                (argorder (argnames args*))
                                ))
              ;; Func arguments
              (addentries 'entry-funcarg funcname args*))

             ;; Simple types
             (('type typename basetype attr ...)
              (let ((me (make ucid-symbol
                               (symtype 'type)
                               (parent #f)
                               (lowerd-type #f) ;; To be lowerd
                               (basetype basetype)
                               (name typename)
                               (sym typename)
                               (attribute-ht (attribute attr)))))
                (append-sym me) ))
             ((otherwise syms ...)
              (case otherwise
                ((constant)
                 (for-each (^e (append-sym (make ucid-symbol
                                                (symtype 'constant)
                                                (parent #f)
                                                (basetype 'uint)
                                                (lowerd-type 'uint)
                                                (sym e)
                                                (name e)
                                                (attribute-ht (attribute '()))
                                                )))
                           syms))
                ((constant/signed)
                 (for-each (^e (append-sym (make ucid-symbol
                                                (symtype 'constant)
                                                (parent #f)
                                                (basetype 'int)
                                                (lowerd-type 'int)
                                                (sym e)
                                                (name e)
                                                (attribute-ht (attribute '()))
                                                )))
                           syms))
                (else
                  (assertion-violation 'gen-ucid
                                      "Invalid form"
                                      e))))))
    (for-each proc x)
    sym*)
  (define (lower! sym*)
    (define sym-ht (make-eq-hashtable))
    (define (lookup sym) (hashtable-ref sym-ht sym #f))
    (define (lookup/ptr+real sym)
      (define s (symbol->string sym))
      (define l (string-length s))
      (define body (substring s 0 (- l 1)))
      (define last (substring s (- l 1) l))
      (values (and (string=? "*" last)
                   (lookup (string->symbol body)))
              (string->symbol body)))
    (define try-next? #f)
    (define (lower e sym)
      ;; Do actual lowering
      ;;Assert try-next? if we succeeded lowering
      ;(display (list 'lowerd (~ e 'name) '=> sym))(newline)
      (~ e 'lowerd-type := sym)
      (set! try-next? #t))
    (define (calc e)
      ;; Calculate lowerd type.
      (let-with e (symtype lowerd-type basetype)
        (unless lowerd-type ;; Try to lower this?
          (cond
            ((not basetype)
             ;; We do not have to do anything for aggregate type entry itself
             (unless (aggregate? e)
               (assertion-violation 'lower
                                    "No basetype??"
                                    e)))
            ((pair? basetype) ;; basetype is an aggregate
             (lower e 'void*))
            ((core-type? basetype)
             (lower e basetype))
            (else
              (let ((b (lookup basetype)))
                (cond
                  ;; Lower the symbol iff the basetype was already lowered
                  (b (when (core-type? (~ b 'lowerd-type))
                       (lower e (~ b 'lowerd-type))))
                  (else
                    (receive (p realbasetype) (lookup/ptr+real basetype)
                      ;; Find basetype* and append (pointer-of l)
                      (cond (p
                              ;; Lower to void*
                              (lower e 'void*)
                              ;; FIXME: Inject pointer-of type
                              )
                            (else
                              (assertion-violation 'lower
                                                   "Cannot find basetype!"
                                                   basetype))))))))))))
    (define (itr)
      (set! try-next? #f)
      (for-each calc sym*)
      (when try-next?
        ;; Try to lower more types
        (itr)))
    ;; Register each symbol into hashtable
    (for-each (^e (let ((x (hashtable-ref sym-ht (~ e 'sym) #f)))
                    (when x
                      (assertion-violation 'sym-ht
                                           "Duplicated symbol!"
                                           (list x e)))
                    (hashtable-set! sym-ht (~ e 'sym) e))) 
              sym*)
    ;; Start lowering
    (itr))
  (define (check-lower-result sym*)
    (for-each (^e (unless (or (aggregate? e) (core-type? (~ e 'lowerd-type)))
                     (assertion-violation 'check-lower
                                          "Symbol was not lowerd"
                                          e)))
              sym*))
  (define (gen-argtype* order* args)
    (define (get-type res sym)
      (or (and (pair? res)
               (eq? (caddar res) sym)
               (core-c-type (caar res))) 
          (get-type (cdr res) sym)))
    (map (cut get-type args <>) order*))
  (define (out+filt-callstub p gexp)
    (fold-left (^[cur e]
                 (match e
                        ((#f funcname rettype argorder args ...)
                         ;; Write callstub source
                         (let ((cname (gen-callstub 
                                        p funcname (core-c-type rettype) 
                                        (gen-argtype* argorder args)
                                        funcname)))
                           (cons (cons 'pointer cname) cur)))
                        (else 
                          (cons e cur))))
               '()
               gexp))
  (define (generate x)
    (match x
           (('c-library src-name libname body ...)
            (let ((srcname (output-file src-name)))
              (when (file-exists? srcname)
                (delete-file srcname))
              ;; First, collect definitions into sym*
              (let ((sym* (output body '() '())))
                ;; Lower symbol types
                (lower! sym*)
                ;; Check
                (check-lower-result sym*)
                ;; Linkup 
                (let ((gexp (linkup sym*)))
                  (pp gexp)
                  ;; generate C source
                  (call-with-output-file
                    srcname
                    (^[csrc]
                      ;; Emit header
                      (csrc-header csrc)
                      ;; Create callstubs
                      (let ((cexp (out+filt-callstub csrc gexp)))
                        ;;(pp cexp)
                        (csrc-exports csrc 
                                      (libname->c-symbol libname) 
                                      cexp))))))))))
  (for-each generate sexp))

(define (genucid dir*)
  (define (locate dir)
    (define lis '())
    (directory-walk
      dir
      (^p (when (string=? (path-basename p) "API.scm")
            (set! lis (cons p lis)))))
    lis)
  
  (for-each gen-ucid
            (apply append (map locate dir*))))

(define (genucid-cmd)
  (let ((c (command-line)))
    (match c
           ((_ in)
            (genucid (list in)))
           (else
             (assertion-violation 'command-line
                                  "Invalid argument"
                                  c)))))

)
